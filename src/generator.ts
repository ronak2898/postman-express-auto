import { Collection, Item, ItemGroup, PropertyList } from 'postman-collection';
import { RouteInfo } from './types';
import { DummyDataGenerator } from './dummy-data';

export class PostmanGenerator {
  private collection: Collection;
  private dataGenerator: DummyDataGenerator;
  private folderMap: Map<string, ItemGroup<Item>>;

  constructor(name: string, private baseUrl: string) {
    this.collection = new Collection({
      info: {
        name,
        schema: 'https://schema.getpostman.com/json/collection/v2.1.0/collection.json'
      }
    } as any);
    
    // Add description after creation
    (this.collection.describe as any) = 'Auto-generated by postman-express-auto';
    
    // Add variables
    this.collection.variables.add({
      key: 'baseUrl',
      value: baseUrl,
      type: 'string'
    } as any);
    
    this.dataGenerator = new DummyDataGenerator();
    this.folderMap = new Map();
  }

  addRoute(route: RouteInfo): void {
    const folder = this.getOrCreateFolder(route.path);
    const item = this.createPostmanItem(route);
    folder.items.add(item);
  }

  private getOrCreateFolder(path: string): ItemGroup<Item> | Collection {
    const parts = path.split('/').filter(p => p && !p.startsWith(':'));
    
    if (parts.length === 0) return this.collection;

    let currentFolder: ItemGroup<Item> | Collection = this.collection;
    let currentPath = '';

    for (const part of parts.slice(0, -1)) {
      currentPath += '/' + part;
      
      if (!this.folderMap.has(currentPath)) {
        const newFolder = new ItemGroup<Item>({ name: part });
        currentFolder.items.add(newFolder as any);
        this.folderMap.set(currentPath, newFolder);
      }

      currentFolder = this.folderMap.get(currentPath)!;
    }

    return currentFolder;
  }

  private createPostmanItem(route: RouteInfo): Item {
    const url = this.buildUrl(route);
    const body = this.shouldHaveBody(route.method) 
      ? this.generateBody(route) 
      : undefined;

    return new Item({
      name: `${route.method} ${route.path}`,
      request: {
        method: route.method,
        header: this.getHeaders(route),
        url,
        body: body ? {
          mode: 'raw',
          raw: JSON.stringify(body, null, 2)
        } as any : undefined
      }
    } as any);
  }

  private shouldHaveBody(method: string): boolean {
    return ['POST', 'PUT', 'PATCH'].includes(method);
  }

  private buildUrl(route: RouteInfo): string {
    let url = '{{baseUrl}}' + route.path;
    
    route.params.forEach(param => {
      url = url.replace(`:${param.name}`, param.example);
    });

    return url;
  }

  private getHeaders(route: RouteInfo): any[] {
    const headers = [];
    
    if (this.shouldHaveBody(route.method)) {
      headers.push({
        key: 'Content-Type',
        value: 'application/json'
      });
    }

    return headers;
  }

  private generateBody(route: RouteInfo): any {
    // Generate body based on route path
    // Check more specific patterns first
    const pathLower = route.path.toLowerCase();
    
    if (pathLower.includes('comment')) {
      return this.dataGenerator.generateCommentData();
    }
    if (pathLower.includes('product')) {
      return this.dataGenerator.generateProductData();
    }
    if (pathLower.includes('user')) {
      return this.dataGenerator.generateUserData();
    }
    if (pathLower.includes('post') || pathLower.includes('article')) {
      return this.dataGenerator.generatePostData();
    }
    
    return this.dataGenerator.generateGenericData();
  }

  getCollection(): any {
    return this.collection.toJSON();
  }
}
